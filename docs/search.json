[
  {
    "objectID": "GA.html",
    "href": "GA.html",
    "title": "Genetic Algorithms in R",
    "section": "",
    "text": "GA hay Genetic Algorithm là 1 thuật toán tối ưu hóa ngẫu nhiên (stochastic search algorithms), được phát triển dựa trên lý thuyết tiến hóa và sự chọn lọc tự nhiên của sinh học (Luca Scrucca 2013).\nỞ thời cấp 3, bạn đã từng học về lý thuyết tiến hóa và chọn lọc tự nhiên của Charles Darwin và Alfred Russel ở môn Sinh học. Nếu bạn cũng từng liệt Sinh như tôi thì bạn quên cũng không sao 😅😅. Vậy thì để tôi giải thích lại như sau:\nSự tiến hóa là sự thay đổi đặc điểm di truyền của 1 quần thể sinh vật, ví dụ điển hình chính là từ loại vượn đã tiến hóa thành hình dạng con người văn minh như các bạn bây giờ. Vậy quá trình tiến hóa đó diễn ra khi có sự chọn lọc tự nhiên tạo ra các biến dị di truyền (Ví dụ: đột biến,…) và kết quả là các cá thể đột biến trở nên phổ biến hơn hoặc hiếm gặp hơn trong quần thể. Vậy điều kiện để xảy ra sự chọn lọc tự nhiên có thể là sự thay đổi về môi trường sống, địa lý,… dẫn tới sự khác nhau về khả năng sống sót và sinh sản.\nKết cục là xuất hiện các cá thể đột biến “mạnh mẽ hơn” hoặc đúng là “đặc biệt hơn” có khả năng tồn tại khi xuất hiện sự thay đổi lớn, ví dụ như dưới đây, do sự thay đổi về địa điểm sống, từ một loại chim sẻ đã phát triển thành 3 phân họ khác nhau.\n\n\n\nHình 1: Ví dụ về chọn lọc tự nhiên\n\n\nVậy lí thuyết này liên quan gì tới vấn đề tối ưu hóa. Thông thường khi bạn muốn tối ưu hóa một vấn đề gì đó, bạn cần xây dựng mô hình định lượng nó, ví dụ như dưới ảnh này ta đang có mô hình MILP nhằm hoạch định tuyến đường và tối ưu hóa quãng đường di chuyển.\n\n\n\nHình 2: Mô hình VRP\n\n\nMục tiêu của hàm chính là tìm ra giá trị nhỏ nhất nghĩa là chi phí cho việc di chuyển của xe là nhỏ nhất. Do đó, bạn có thể hình dung rằng giá trị nhỏ nhất đó như là các cá thể đột biến có khả năng sống sót cao nhất trong quẩn thể.\nVì vậy thuật toán Genetic (GA) chính là lặp đi lặp lại sự chọn lọc tự nhiên trong một quần thể hoặc một mẫu để đến cuối cùng tìm ra cá thể vượt trội nhất.\n\n\n\nTrong Machine Learning, GA nhằm tìm ra đúng các biến cần thiết để xây dựng mô hình tốt nhất. Gỉa sử chúng ta có 2 mô hình là:\n\nMô hình 1: gồm các biến A,C,D.\nMô hình 2: gồm biến A,B,E.\n\nVậy mô hình nào mới là tốt nhất cho mô hình dự đoán ? Chúng ta chưa biết được và chỉ có thể so sánh nó thông qua thuật toán Genetic.\nVề quy trình, thuật toán Genetic sẽ có cách hoạt động như dưới đây. Quy trình này mình tham khảo của (Rohith Gandhi 2018).\n\n\n\nHình 3: Thuật toán Genetic\n\n\nDiễn giải cách hoạt động:\n\nBước 1 (Initialisation): mỗi biến được xem là Gene và nhiều Gene gộp lại thành một mô hình hay gọi là Chromosome và nhiều Chromosome sẽ tạo thành một quần thể (Population). Việc này giống như là bạn đang trình bày hết các phương án có thể sử dụng.\n\n\n\n\nHình 4: Các thuật ngữ trong GA\n\n\n\nBước 2 (Fitness Function): Bạn cần xây dựng một hàm mục tiêu để tính toán giá trị cho các mô hình ở bước 1.\nBước 3 (Selection): Biến nào có giá trị yếu kém sẽ bị loại và quá trình tính toán sẽ tiếp tục ở thế hệ của nó tiếp theo. Diễn giải đơn giản hơn là chúng ta thử một cách khác và cố gắng cải thiện kết quả.\nBước 4 (Crossover): Tạo ra mô hình gồm các biến tốt đã lựa chọn ở bước 3. Ví dụ như biến A, B là tốt cho mô hình.\nBước 5 (Mutation): Thay đổi mô hình đầu vào đã bao gồm các biến ở bước 4 và bắt đầu lại từ bước 1. Ví dụ mô hình cần chọn gồm 5 biến và ta đã chọn được biến A,B là tốt. Do đó, khi quay lại bước 1, ta chỉ cần chọn thêm 3 biến thay vì 5 biến như thông thường."
  },
  {
    "objectID": "GA.html#vài-điểm-về-thuật-toán-genetic",
    "href": "GA.html#vài-điểm-về-thuật-toán-genetic",
    "title": "Genetic Algorithms in R",
    "section": "",
    "text": "GA hay Genetic Algorithm là 1 thuật toán tối ưu hóa ngẫu nhiên (stochastic search algorithms), được phát triển dựa trên lý thuyết tiến hóa và sự chọn lọc tự nhiên của sinh học (Luca Scrucca 2013).\nỞ thời cấp 3, bạn đã từng học về lý thuyết tiến hóa và chọn lọc tự nhiên của Charles Darwin và Alfred Russel ở môn Sinh học. Nếu bạn cũng từng liệt Sinh như tôi thì bạn quên cũng không sao 😅😅. Vậy thì để tôi giải thích lại như sau:\nSự tiến hóa là sự thay đổi đặc điểm di truyền của 1 quần thể sinh vật, ví dụ điển hình chính là từ loại vượn đã tiến hóa thành hình dạng con người văn minh như các bạn bây giờ. Vậy quá trình tiến hóa đó diễn ra khi có sự chọn lọc tự nhiên tạo ra các biến dị di truyền (Ví dụ: đột biến,…) và kết quả là các cá thể đột biến trở nên phổ biến hơn hoặc hiếm gặp hơn trong quần thể. Vậy điều kiện để xảy ra sự chọn lọc tự nhiên có thể là sự thay đổi về môi trường sống, địa lý,… dẫn tới sự khác nhau về khả năng sống sót và sinh sản.\nKết cục là xuất hiện các cá thể đột biến “mạnh mẽ hơn” hoặc đúng là “đặc biệt hơn” có khả năng tồn tại khi xuất hiện sự thay đổi lớn, ví dụ như dưới đây, do sự thay đổi về địa điểm sống, từ một loại chim sẻ đã phát triển thành 3 phân họ khác nhau.\n\n\n\nHình 1: Ví dụ về chọn lọc tự nhiên\n\n\nVậy lí thuyết này liên quan gì tới vấn đề tối ưu hóa. Thông thường khi bạn muốn tối ưu hóa một vấn đề gì đó, bạn cần xây dựng mô hình định lượng nó, ví dụ như dưới ảnh này ta đang có mô hình MILP nhằm hoạch định tuyến đường và tối ưu hóa quãng đường di chuyển.\n\n\n\nHình 2: Mô hình VRP\n\n\nMục tiêu của hàm chính là tìm ra giá trị nhỏ nhất nghĩa là chi phí cho việc di chuyển của xe là nhỏ nhất. Do đó, bạn có thể hình dung rằng giá trị nhỏ nhất đó như là các cá thể đột biến có khả năng sống sót cao nhất trong quẩn thể.\nVì vậy thuật toán Genetic (GA) chính là lặp đi lặp lại sự chọn lọc tự nhiên trong một quần thể hoặc một mẫu để đến cuối cùng tìm ra cá thể vượt trội nhất."
  },
  {
    "objectID": "GA.html#cách-hoạt-động-ga-trong-ml",
    "href": "GA.html#cách-hoạt-động-ga-trong-ml",
    "title": "Genetic Algorithms in R",
    "section": "",
    "text": "Trong Machine Learning, GA nhằm tìm ra đúng các biến cần thiết để xây dựng mô hình tốt nhất. Gỉa sử chúng ta có 2 mô hình là:\n\nMô hình 1: gồm các biến A,C,D.\nMô hình 2: gồm biến A,B,E.\n\nVậy mô hình nào mới là tốt nhất cho mô hình dự đoán ? Chúng ta chưa biết được và chỉ có thể so sánh nó thông qua thuật toán Genetic.\nVề quy trình, thuật toán Genetic sẽ có cách hoạt động như dưới đây. Quy trình này mình tham khảo của (Rohith Gandhi 2018).\n\n\n\nHình 3: Thuật toán Genetic\n\n\nDiễn giải cách hoạt động:\n\nBước 1 (Initialisation): mỗi biến được xem là Gene và nhiều Gene gộp lại thành một mô hình hay gọi là Chromosome và nhiều Chromosome sẽ tạo thành một quần thể (Population). Việc này giống như là bạn đang trình bày hết các phương án có thể sử dụng.\n\n\n\n\nHình 4: Các thuật ngữ trong GA\n\n\n\nBước 2 (Fitness Function): Bạn cần xây dựng một hàm mục tiêu để tính toán giá trị cho các mô hình ở bước 1.\nBước 3 (Selection): Biến nào có giá trị yếu kém sẽ bị loại và quá trình tính toán sẽ tiếp tục ở thế hệ của nó tiếp theo. Diễn giải đơn giản hơn là chúng ta thử một cách khác và cố gắng cải thiện kết quả.\nBước 4 (Crossover): Tạo ra mô hình gồm các biến tốt đã lựa chọn ở bước 3. Ví dụ như biến A, B là tốt cho mô hình.\nBước 5 (Mutation): Thay đổi mô hình đầu vào đã bao gồm các biến ở bước 4 và bắt đầu lại từ bước 1. Ví dụ mô hình cần chọn gồm 5 biến và ta đã chọn được biến A,B là tốt. Do đó, khi quay lại bước 1, ta chỉ cần chọn thêm 3 biến thay vì 5 biến như thông thường."
  },
  {
    "objectID": "GA.html#thuật-toán-genetic",
    "href": "GA.html#thuật-toán-genetic",
    "title": "Genetic Algorithms in R",
    "section": "2.1 Thuật toán Genetic:",
    "text": "2.1 Thuật toán Genetic:\nVậy bây giờ chúng ta sẽ xử lí bài toán trên theo thuật toán Genetic\nGỉa sử chúng ta có bài toán về vận chuyển hàng từ nhà kho để thỏa mãn nhu cầu ở các điểm DC (Distribution center). Và công thức để tính toán được chi phí là:\nHàm chi phí tổng thể được xác định như sau:\n\\[\nTC = \\sum_{i=1}^{m} \\left( D_{ij} \\times \\frac{P}{F} \\times 0.4 + LC_i \\right) \\times Q_j\n\\] Vì vậy, nếu trong công việc, chúng ta sẽ cần lấy dữ liệu từ Data warehouse bằng SQL hoặc các phần mềm Business Intelligence khác. Ở đây, nhằm minh họa, mình đã tạo ra code ở phía dưới để các bạn luyện tập.\n\n\nCode\n# Create a data frame for loading costs\nloading_costs &lt;- data.frame(\n  Warehouse = rep(paste(\"Warehouse\", 1:5), each = 4),\n  ID = rep(1:5, times = 4),\n  Weight_Category = rep(c(\"&lt; 2 tons\", \"2 to 5 tons\", \"5 to 10 tons\", \"&gt; 10 tons\"), times = 5),\n  Has_Machine = rep(c(\"Yes\", \"No\", \"Yes\", \"No\", \"No\"), each = 4),\n  Loading_Cost = c(80, 100, 120, 160,  # Warehouse 1 (with machine)\n                   110, 150, 180, 210,  # Warehouse 2 (without machine)\n                   85, 105, 125, 140,  # Warehouse 3 (with machine)\n                   150, 170, 190, 210,  # Warehouse 4 (without machine)\n                   140, 165, 185, 215)   # Warehouse 5 (without machine)\n)\n\n# Define warehouses with coordinates (latitude, longitude)\nwarehouses &lt;- data.frame(\n  ID = 1:5,\n  Latitude = c(21.0285, 16.0545, 10.7769, 14.0583, 19.8060), # Example latitudes (Hanoi, HCMC, Da Nang, etc.)\n  Longitude = c(105.804, 108.2022, 106.6957, 108.2772, 105.7460) # Example longitudes\n)\n\n# Define distribution centers data in Vietnam (example coordinates)\ndistribution_centers &lt;- data.frame(\n  ID = 1:3,\n  Demand = c(90, 30, 150),\n  Latitude = c(17.974855, 10.7769, 15.122327), # Example latitudes (Hanoi, Da Nang, HCMC)\n  Longitude = c(102.630867, 106.6957, 108.799357) # Example longitudes\n)\n\n\nNếu bạn gặp khó khăn trong việc phải đối mặt với cả đống dữ liệu từ hệ thống và chưa biết lấy dữ liệu nào để phân tích hoặc gộp bảng nào qua bảng nào thì lời khuyên của tôi là hãy vẽ bảng Entity relation diagram (ERD).\nERD là một công cụ trực quan dùng để mô tả cấu trúc dữ liệu trong cơ sở dữ liệu. ERD thể hiện các thực thể (entities), thuộc tính (attributes), và các mối quan hệ (relationships) giữa chúng. Các thực thể thường được biểu diễn dưới dạng hình chữ nhật, thuộc tính dưới dạng hình ellips, và mối quan hệ bằng hình thoi hoặc đường nối. ERD giúp lập kế hoạch cho thiết kế cơ sở dữ liệu, đảm bảo rằng các yếu tố dữ liệu và quan hệ giữa chúng được xác định rõ ràng, tạo nền tảng cho việc phát triển và quản lý dữ liệu hiệu quả.\nCác bạn có thể thấy mối quan hệ thông qua bảng Entity relation diagram (ERD) dưới đây:\n\n\n\n\n\n\n\n\n\n\n\n\n\nTải package datamodelr:\n\n\n\nMình tạo biểu đồ này bằng thư viện datamodelr. Bạn có thể tải bằng cú pháp: devtools::install_github(\"bergant/datamodelr\")\n\n\nNhư vậy, dựa vào đó, ta sẽ tính toán được 2 bảng quan trọng:\n\nBảng giá loading ở các kho. (Hình bên trái)\nBảng chi phí vận chuyển từ từng WH đến các DCs. (Hình bên phải)\n\n\n\nCode\n## Calculate the transportation cost:\n# Haversine distance function\nhaversine &lt;- function(lat1, lon1, lat2, lon2) {\n  R &lt;- 6371 # Radius of Earth in kilometers\n  dlat &lt;- (lat2 - lat1) * pi / 180\n  dlon &lt;- (lon2 - lon1) * pi / 180\n  a &lt;- sin(dlat / 2) * sin(dlat / 2) +\n       cos(lat1 * pi / 180) * cos(lat2 * pi / 180) * \n       sin(dlon / 2) * sin(dlon / 2)\n  c &lt;- 2 * atan2(sqrt(a), sqrt(1 - a))\n  R * c # Distance in kilometers\n}\n\n# Calculate distance matrix based on coordinates\ndistance_matrix &lt;- matrix(0, nrow = nrow(warehouses), ncol = nrow(distribution_centers))\n\nfor (i in 1:nrow(warehouses)) {\n  for (j in 1:nrow(distribution_centers)) {\n    distance_matrix[i, j] &lt;- haversine(\n      warehouses$Latitude[i], warehouses$Longitude[i],\n      distribution_centers$Latitude[j], distribution_centers$Longitude[j]\n    )\n  }\n}\n\n# Define the fuel price (example value)\nfuel_price &lt;- 20 # Fuel price per kilometer\n\n# Calculate transportation costs\ntransportation_costs &lt;- distance_matrix * fuel_price * 0.4\n\n## Calculate the loading cost:\nweights_per_good &lt;- 0.1\n\n# Calculate total weight for each distribution center\ntotal_weight &lt;- distribution_centers$Demand * weights_per_good\n\n# Function to get loading cost based on total weight\nget_loading_cost &lt;- function(total_weight) {\n  if (total_weight &lt; 2) {\n    loading_costs %&gt;% filter(Weight_Category == \"&lt; 2 tons\") %&gt;% pull(Loading_Cost)\n  } else if (total_weight &gt;= 2 & total_weight &lt; 5) {\n    loading_costs %&gt;% filter(Weight_Category == \"2 to 5 tons\") %&gt;% pull(Loading_Cost)\n  } else if (total_weight &gt;= 5 & total_weight &lt; 10) {\n    loading_costs %&gt;% filter(Weight_Category == \"5 to 10 tons\") %&gt;% pull(Loading_Cost)\n  } else {\n    loading_costs %&gt;% filter(Weight_Category == \"&gt; 10 tons\") %&gt;% pull(Loading_Cost)\n  }\n}\n\n# Calculate loading costs based on total weights for each distribution center\nloading_costs_per_dc &lt;- sapply(total_weight, \n                               get_loading_cost)\n\n\n\n\n\n\n\n\n\n\n\n\nSau khi đã có đủ dữ liệu, bạn sẽ bắt đầu viết hàm mục tiêu và dùng thuật toán GA để tìm ra giá trị tối ưu nhất.\nTrong hàm ga từ gói GA trong R, có một số đối số quan trọng cho phép bạn tùy chỉnh thuật toán di truyền. Dưới đây là một cái nhìn tổng quan về một số đối số quan trọng:\n\ntype: Chỉ định loại tối ưu hóa (ví dụ: \"real-valued\", \"binary\" hoặc \"permutation\").\nfitness: Hàm đánh giá độ phù hợp; nó nên nhận một vector tham số làm đầu vào và trả về một giá trị số.\nlower và upper: Định nghĩa giới hạn cho các biến nếu bạn đang tối ưu hóa trong không gian liên tục (dùng cho các loại giá trị thực).\npopSize: Thiết lập kích thước quần thể cho mỗi thế hệ.\nmaxiter: Chỉ định số thế hệ tối đa để chạy thuật toán.\nrun: Chỉ định số thế hệ để chạy thuật toán mà không có sự cải thiện trước khi dừng lại.\npmutation: Xác suất xảy ra đột biến trong quần thể.\nelitism: Xác định xem các cá thể tốt nhất có nên được giữ lại trong thế hệ tiếp theo hay không.\n\nNhững đối số này giúp điều chỉnh thuật toán di truyền cho các nhu cầu tối ưu hóa cụ thể của bạn, cho phép hiệu suất tốt hơn và hội tụ về các giải pháp tối ưu.\nNgoài ra, còn có các lưu ý cho bạn khi sử dụng R như sau:\n\n\n\n\n\n\nLưu ý khi dùng hàm ga():\n\n\n\nHàm ga() phải có ít nhất 2 đối số là type và fitness thì R mới chạy được.\n\nRiêng khi type = “binary” thì cần thêm đối số nBits.\nCòn khi type = \"real-valued\"/\"permutation\" thì cần thêm đối số min và max.\n\n\n\n\n\nCode\n# Load necessary library\nlibrary(GA)\ndemand&lt;-c(distribution_centers$Demand)\n\ncost_matrix = transportation_costs + loading_costs_per_dc\n# Define the transportation cost matrix\n\n# Define the objective function\nobjective_function &lt;- function(quantities) {\n    quantities_matrix &lt;- matrix(quantities, \n                                nrow = 5, \n                                ncol = 3, \n                                byrow = TRUE)\n    \n    total_cost &lt;- sum(quantities_matrix * cost_matrix)\n    \n    # Check if demands are met\n    if (any(colSums(quantities_matrix) &lt; demand)) {\n        return(Inf)  # Penalize if demands are not met\n    }\n    \n    return(total_cost)\n}\n\n# Set up the Genetic Algorithm\nnum_vars &lt;- 5 * 3  # 5 warehouses, 3 distribution centers\nga_result &lt;- ga(\n    type = \"real-valued\",\n    fitness = function(x) -objective_function(x),  # Negate for maximization\n    lower = rep(0, num_vars),  # Minimum quantity\n    upper = rep(100, num_vars),  # Maximum quantity (adjust as needed)\n    popSize = 50,\n    maxiter = 100,\n    run = 10,\n    monitor = TRUE\n)\n\n\nVà cuối cùng, sau khi có kết quả, mình sẽ dùng các thư viện gồm: Leaflet, gt, và biểu đồ Sankey phục vụ những mục đích khác nhau cho trực quan hóa dữ liệu.\n\nLeaflet: Đây là một thư viện mạnh mẽ để tạo bản đồ tương tác. Nó cho phép người dùng dễ dàng thêm các lớp, điểm đánh dấu và pop-up, rất lý tưởng để trực quan hóa dữ liệu địa lý. Leaflet đặc biệt hữu ích để hiển thị các dữ liệu như vị trí, lộ trình, hoặc phân bố không gian.\ngt: Gói gt được thiết kế để tạo ra các bảng chất lượng cao trong R. Nó cho phép người dùng định dạng và tạo kiểu cho bảng một cách dễ dàng, giúp chúng trở nên hấp dẫn và dễ đọc. gt hỗ trợ các tính năng như định dạng tùy chỉnh, dòng tóm tắt, và thậm chí thêm chú thích, nâng cao cách trình bày dữ liệu trong báo cáo.\nBiểu đồ Sankey: Những biểu đồ này được sử dụng để trực quan hóa luồng và mối quan hệ giữa các danh mục khác nhau. Trong R, gói networkD3 hoặc ggalluvial có thể tạo ra biểu đồ Sankey, giúp hiểu cách các giá trị di chuyển giữa các nút, chẳng hạn như theo dõi hành trình người dùng hoặc hiển thị phân bổ tài nguyên.\n\nNhìn chung, những công cụ này cung cấp các lựa chọn mạnh mẽ để trình bày dữ liệu một cách hấp dẫn và thông tin. Bạn có thể lựa chọn 1 trong 3 chúng, vì lý do học nên mình trình bày cả 3 luôn!.\n\n\nCode\nlibrary(leaflet)\n\n# Create custom icons\nwarehouse_icon &lt;- makeIcon(\n      iconUrl = \"C:/Users/locca/Documents/Xuân Lộc/R/Project R/Genetic-Algorithm/warehouse_icon.png\",  # Update with your actual file path\n      iconWidth = 30, \n      iconHeight = 30\n    )\n\ndc_icon &lt;- makeIcon(\n      iconUrl = \"C:/Users/locca/Documents/Xuân Lộc/R/Project R/Genetic-Algorithm/distribution_center.png\",  # Update with your actual file path\n      iconWidth = 30, \n      iconHeight = 30\n    )\n    \n    # Assuming ga_result@solution contains optimal quantities\nga_result_solution &lt;- c(ga_result@solution)\n\n# Reshape the solution into a matrix (5 warehouses x 3 DCs)\noptimal_quantities &lt;- matrix(ga_result@solution,\n                             nrow = 5, \n                             ncol = 3, \n                             byrow = TRUE)\n\n    # Create the leaflet map\nmap &lt;- leaflet() %&gt;% \n      addTiles() %&gt;%\n      addMarkers(data = warehouses, \n                 lat = ~Latitude, lng = ~Longitude, \n                 popup = ~paste(\"Warehouse ID:\", ID), \n                 icon = warehouse_icon) %&gt;%\n      addMarkers(data = distribution_centers, \n                 lat = ~Latitude, lng = ~Longitude, \n                 popup = ~paste(\"DC ID:\", ID, \"&lt;br&gt;Demand:\", Demand), \n                 icon = dc_icon)\n\n    # Add routes based on the optimal quantities\n    for (i in 1:nrow(optimal_quantities)) {\n      for (j in 1:ncol(optimal_quantities)) {\n        if (optimal_quantities[i, j] &gt; 0) {\n          route_start &lt;- warehouses[warehouses$ID == i, c(\"Longitude\", \"Latitude\")]\n          route_end &lt;- distribution_centers[distribution_centers$ID == j, c(\"Longitude\", \"Latitude\")]\n          \nmap &lt;- map %&gt;%\n            addPolylines(lat = c(route_start$Latitude, route_end$Latitude),\n                         lng = c(route_start$Longitude, route_end$Longitude),\n                         color = \"black\", weight = 2, opacity = 0.5)\n        }\n      }\n    }\n\nmap %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) \nlibrary(gt)\nlibrary(gtExtras)\n\n    # Convert GA solution to a data frame\nresult &lt;- as.data.frame(matrix(ga_result@solution, nrow = 5, byrow = TRUE))\n    colnames(result) &lt;- c(\"DC1\", \"DC2\", \"DC3\")\n    rownames(result) &lt;- c(\"WH1\", \"WH2\", \"WH3\", \"WH4\", \"WH5\")\nresult &lt;- cbind(Workload = rownames(result), result)\n\nresult_long &lt;- result %&gt;% \n  pivot_longer(cols = starts_with(\"DC\"), names_to = \"Distribution_Center\", values_to = \"Quantity\")\n    # Create and display the table\nresult_long %&gt;%\n  gt() %&gt;%\n  tab_header(title = \"Details Planning Table\") %&gt;%\n  cols_label(Distribution_Center = \"Distribution Center\") %&gt;% \n  tab_row_group(\n    label = html(\"&lt;strong&gt;&lt;img src='https://upload.wikimedia.org/wikipedia/commons/5/56/Flag_of_Laos.svg' width='20' /&gt; Laos&lt;/strong&gt;\"),\n    rows = Distribution_Center == \"DC1\"\n  ) %&gt;% \n  tab_row_group(\n    label = html(\"&lt;strong&gt;&lt;img src='https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Flag_of_Vietnam.svg/345px-Flag_of_Vietnam.svg.png' width='20' /&gt; Vietnam&lt;/strong&gt;\"),\n    rows = Distribution_Center %in% c(\"DC2\", \"DC3\")\n  ) %&gt;% \n  fmt_number(columns = c(Quantity), decimals = 2) %&gt;%\n  cols_label(Workload = \"Warehouse\") %&gt;%\n  tab_style(style = list(cell_text(align = \"center\")),\n            locations = cells_body(columns = everything())) %&gt;%\n  tab_source_note(source = md(\"*Source: package gt in R*\")) %&gt;%\n  gt_theme_excel() %&gt;%\n  summary_rows(\n    groups = everything(),\n    columns = Quantity, \n    fns = list(Total = ~sum(.),\n               Count = ~n()))%&gt;% \n  tab_footnote(\n    footnote = md(\"**Count** means number of shipment.\"),\n    locations = cells_summary(rows = \"Count\")\n  ) %&gt;% \n  tab_footnote(\n    footnote = md(\"**Total** means the optimal quantity of good.\"),\n    locations = cells_summary(rows = \"Total\")\n  ) \nlibrary(networkD3)\nlibrary(jsonlite)\n\n# Define colors for nodes\ncolors &lt;- c(\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\")\n\n# Define example data\nWarehouses &lt;- c(\"Warehouse 1\", \"Warehouse 2\", \"Warehouse 3\", \"Warehouse 4\", \"Warehouse 5\")\nDistribution_centers &lt;- c(\"DC 1\", \"DC 2\", \"DC 3\")\n\n# Create nodes data frame\nnodes &lt;- data.frame(name = c(Warehouses, Distribution_centers))\n\n# Assign colors based on node index\nnode_colors &lt;- c(rep(1:length(Warehouses), each = 1), rep(length(Warehouses) + 1:length(Distribution_centers), each = 1))\n\n# Create links data frame\nlinks &lt;- data.frame(\n  source = rep(0:(nrow(optimal_quantities) - 1), each = ncol(optimal_quantities)),  \n  target = as.vector(sapply(0:(ncol(optimal_quantities) - 1), \n                             function(j) rep(nrow(optimal_quantities) + j, nrow(optimal_quantities)))),  \n  value = as.vector(optimal_quantities)  \n)\n\n# Create a Sankey diagram with node colors\nsankey &lt;- sankeyNetwork(Links = links, \n                        Nodes = nodes, \n                        Source = \"source\", \n                        Target = \"target\", \n                        Value = \"value\",\n                        NodeID = \"name\",\n                        colourScale = JS(paste0(\"d3.scaleOrdinal().domain([0,\", length(colors) - 1, \"]).range(\", toJSON(colors), \");\")),\n                        height = 900,  # Adjust height to reduce vertical space\n                        width = 1000)   # Adjust width to fit more nodes in one line\n\n\n## Add title and caption:\nsankey &lt;- htmlwidgets::prependContent(sankey, htmltools::tags$h1(\"Sankey chart\"))\nsankey &lt;- htmlwidgets::appendContent(sankey, htmltools::tags$p(style = \"font-size: 14px; text-align: center;\", \" A wider arrow indicates that a larger quantity is being sent from that warehouse to a distribution center.\"))\n\n# Display the Sankey diagram\nsankey\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n      Details Planning Table\n    \n    \n    \n      \n      Warehouse\n      Distribution Center\n      Quantity\n    \n  \n  \n    \n       Vietnam\n    \n    \nWH1\nDC2\n11.14\n    \nWH1\nDC3\n9.35\n    \nWH2\nDC2\n33.06\n    \nWH2\nDC3\n45.37\n    \nWH3\nDC2\n80.42\n    \nWH3\nDC3\n70.16\n    \nWH4\nDC2\n12.31\n    \nWH4\nDC3\n24.31\n    \nWH5\nDC2\n12.82\n    \nWH5\nDC3\n13.95\n    Total\n—1\n—1\n312.86831\n    Count\n—2\n—2\n10.00002\n    \n       Laos\n    \n    \nWH1\nDC1\n27.76\n    \nWH2\nDC1\n25.81\n    \nWH3\nDC1\n19.06\n    \nWH4\nDC1\n17.24\n    \nWH5\nDC1\n11.38\n    Total\n—1\n—1\n101.25231\n    Count\n—2\n—2\n5.00002\n  \n  \n    \n      Source: package gt in R\n\n    \n  \n  \n    \n      1 Total means the optimal quantity of good.\n\n    \n    \n      2 Count means number of shipment.\n\n    \n  \n\n\n\n\nSankey chart\n\n A wider arrow indicates that a larger quantity is being sent from that warehouse to a distribution center."
  },
  {
    "objectID": "GA.html#mô-hình-milp",
    "href": "GA.html#mô-hình-milp",
    "title": "Genetic Algorithms in R",
    "section": "2.2 Mô hình MILP:",
    "text": "2.2 Mô hình MILP:\n\n2.2.1 Giới thiệu sơ lược:\nMILP (Mixed Integer Linear Programming) là một phương pháp tối ưu hóa được sử dụng trong các bài toán lập kế hoạch, phân bổ tài nguyên, và quyết định trong các lĩnh vực như logistics, sản xuất, tài chính, và nhiều lĩnh vực khác. MILP là một phần mở rộng của lập trình tuyến tính (Linear Programming - LP), trong đó có các biến là số nguyên (integer variables) bên cạnh các biến liên tục (continuous variables).\nTrong đó, cấu trúc của một bài toán MILP bao gồm:\n\nHàm mục tiêu: Là một hàm tuyến tính mà bạn muốn tối ưu hóa (tối đa hóa hoặc tối thiểu hóa).\n\\[\n\\text{Maximize or Minimize } Z = c_1x_1 + c_2x_2 + \\ldots + c_nx_n\n\\]\nRàng buộc: Bao gồm các điều kiện tuyến tính mà các biến phải thỏa mãn.\n\\[\na_{11}x_1 + a_{12}x_2 + \\ldots + a_{1n}x_n \\leq b_1\n\\]\n\\[\na_{21}x_1 + a_{22}x_2 + \\ldots + a_{2n}x_n \\leq b_2\n\\]\n… và nhiều ràng buộc khác.\nBiến quyết định: Các biến trong bài toán có thể là:\n\nBiến liên tục: Có thể nhận mọi giá trị thực (ví dụ: số lượng sản phẩm).\nBiến nguyên: Chỉ nhận giá trị nguyên (ví dụ: số lượng xe tải).\nBiến nhị phân: Chỉ nhận giá trị 0 hoặc 1 (ví dụ: có hoặc không sử dụng một nhà máy).\n\n\nỨng dụng của MILP\n\nQuản lý chuỗi cung ứng: Tối ưu hóa việc phân phối hàng hóa từ các kho đến các khách hàng.\nLập kế hoạch sản xuất: Xác định số lượng sản phẩm cần sản xuất để tối đa hóa lợi nhuận hoặc giảm chi phí.\nTối ưu hóa lịch trình: Lập lịch cho nhân viên, máy móc, hoặc tài nguyên để tối ưu hóa hiệu suất.\nQuy hoạch đô thị: Tối ưu hóa việc sử dụng đất và tài nguyên trong quy hoạch thành phố.\n\nTrong R có các thư viện như lpSolve, ompr, và ROI có thể được sử dụng để giải quyết các bài toán MILP.\n\n\n2.2.2 Ví dụ:\nMILP là một công cụ mạnh mẽ cho việc tối ưu hóa trong nhiều lĩnh vực khác nhau. Với khả năng kết hợp giữa các biến liên tục và số nguyên, MILP có thể giải quyết nhiều bài toán phức tạp mà các phương pháp tối ưu hóa khác không thể thực hiện hiệu quả.\nGỉa sử ta có bài toán về vấn đề Transshipment có yêu cầu là tìm ra phương án vận tải tối ưu nhất để vận chuyển hàng hóa từ nhà máy (Factory) thông qua Crossdocking và đến được Distribution Center với mục tiêu là đạt chi phí thấp nhất.\n\n\n\nHình 5: Vấn đề Transshipment\n\n\nVì bài toán này thuộc dạng tuyến tính, phương pháp MILP sẽ làm tốt hơn nhiều so với thuật toán GA bên trên.\n\n\nCode\nlibrary(ompr)\nlibrary(ompr.roi)\nlibrary(ROI.plugin.glpk)\n#Input:\nSupply &lt;-c(200,300,100,150,220)\nDemand &lt;-c(150,100,110,200,180)\nDC&lt;-2\nm&lt;-length(Supply)\nn&lt;-length(Demand)\n\nCost_CD&lt;-read.table(text = \n                    \"CD1 CD2\n                     30 50\n                     23 66\n                     35 14\n                     70 12\n                     65 70\",header = T)\nCost_DC&lt;-read.table(text = \n                      \"DC1 DC2 DC3 DC4 DC5\n                       12 25 22 40 41\n                       65 22 23 12 15\",header = T)\n\n#MILP model from the \nmodel5 &lt;- MIPModel() %&gt;%\n  # Add variable\n  add_variable(x[i, j], i = 1:m, j = 1:DC) %&gt;%\n  add_variable(y[j, k], j = 1:DC, k = 1:n) %&gt;%\n  # minimize the cost of transshipment:\n  set_objective(sum_expr(x[i, j]*Cost_CD[i, j],i = 1:m, j = 1:DC)+ sum_expr(y[j, k]*Cost_DC[j, k], k = 1:n, j = 1:DC),\"min\") %&gt;%\n  add_constraint(sum_expr(y[j, k], j = 1:DC) &gt;= Demand[k], k = 1:n) %&gt;%\n  # The amount of inventory in Crossdocking is smaller than production goods\n  add_constraint(sum_expr(x[i, j], j = 1:DC) &lt;= Supply[i], i = 1:m) %&gt;% \n  # The amount of is bigger than demand in DC\n  add_constraint(sum_expr(x[i, j], i = 1:m) - sum_expr(y[j, k], k = 1:n) &gt;= 0,j = 1:DC) %&gt;%\n  add_constraint(x[i, j] &gt;= 0, j = 1:DC, i = 1:m)%&gt;% \n  add_constraint(y[j, k] &gt;= 0, j = 1:DC, k = 1:n)%&gt;% \n  #Solve the model:\n  solve_model(with_ROI(solver = \"glpk\", verbose = TRUE))\n\n\n\n\nCode\n## Barchart:\nsolution &lt;- get_solution(model5, x[i, j]) %&gt;% \n     filter(value &gt; 0)\n\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Assuming `solution` contains the results of x[i, j]\n# Transform the solution into a tidy format for plotting\nplot_data &lt;- solution %&gt;%\n  rename(Manufacter= i, DC = j, Flow = value) %&gt;%\n  mutate(Manufacter = paste(\"Manufacter\", Manufacter),\n         DC = paste(\"DC\", DC))\n\n# Create a plot\nggplot(plot_data, aes(x = Manufacter, y = Flow, fill = DC)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  theme_minimal() +\n  labs(title = \"Transshipment Flow from Manufacters to Distribution Centers\",\n       x = \"Manufacters\",\n       y = \"Flow Amount\",\n       fill = \"Distribution Centers\") +\n  theme(text = element_text(size = 12),\n        axis.text.x = element_text(angle = 45, hjust = 1)) +\n  scale_fill_brewer(palette = \"Set2\")\nlibrary(gt)\n\n# Assuming `solution` contains the results of x[i, j]\n# Transform the solution into a tidy format for the table\ntable_data &lt;- solution %&gt;%\n  rename(Manufacturer = i, DC = j, Flow = value) %&gt;%\n  mutate(Manufacturer = paste(\"Manufacturer\", Manufacturer),\n         DC = paste(\"DC\", DC)) %&gt;% \n  select(-variable)\n\n# Create a gt table\ntable_data %&gt;%\n  gt() %&gt;%\n  tab_header(\n    title = md(\"**Transshipment Flows from Manufacturers to Distribution Centers**\")\n  ) %&gt;%\n  cols_label(\n    Manufacturer = \"Manufacturer\",\n    DC = \"Distribution Center\",\n    Flow = \"Flow Amount\"\n  ) %&gt;%\n  fmt_number(\n    columns = c(Flow),\n    decimals = 2\n  ) %&gt;%\n  tab_style(\n    style = list(\n      cell_fill(color = \"lightblue\")\n    ),\n    locations = cells_body(\n      columns = c(Flow),\n      rows = Flow &gt; 0\n    )\n  ) %&gt;%\n  tab_options(\n    table.width = pct(100)\n  ) %&gt;% \n  gt_theme_excel()\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n      Transshipment Flows from Manufacturers to Distribution Centers\n\n    \n    \n    \n      Manufacturer\n      Distribution Center\n      Flow Amount\n    \n  \n  \n    Manufacturer 1\nDC 1\n60.00\n    Manufacturer 2\nDC 1\n300.00\n    Manufacturer 1\nDC 2\n130.00\n    Manufacturer 3\nDC 2\n100.00\n    Manufacturer 4\nDC 2\n150.00\n  \n  \n  \n\n\n\n\n\n\n\n\n\nShare\n\nVisit my GitHub"
  }
]